lets also add a sentiment tracking agent 
/**
 * INSTAGRAM INTELLIGENCE AGENT - DATABASE SCHEMA
 * Extends the main schema with agent-specific tables
 */

import { int, mysqlEnum, mysqlTable, text, timestamp, varchar, json, float, boolean } from "drizzle-orm/mysql-core";
import { relations } from "drizzle-orm";

// ============================================================================
// CAMPAIGNS
// ============================================================================

export const campaigns = mysqlTable("campaigns", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("user_id").notNull(),
  accountId: int("account_id").notNull(),
  
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  
  // Campaign goals
  goal: mysqlEnum("goal", [
    "awareness",      // Brand awareness
    "engagement",     // Drive engagement
    "traffic",        // Drive traffic
    "conversions",    // Drive conversions
    "followers"       // Grow followers
  ]).notNull(),
  
  targetMetric: varchar("target_metric", { length: 50 }), // e.g., "reach", "engagement_rate"
  targetValue: float("target_value"), // e.g., 10000 reach or 5% engagement
  
  // Campaign details
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date"),
  budget: float("budget"), // Optional budget tracking
  
  // Status
  status: mysqlEnum("status", ["active", "paused", "completed", "archived"]).default("active").notNull(),
  
  // Metadata
  tags: json("tags").$type<string[]>(), // Campaign tags
  
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().onUpdateNow().notNull(),
});

export type Campaign = typeof campaigns.$inferSelect;
export type InsertCampaign = typeof campaigns.$inferInsert;

// ============================================================================
// CAMPAIGN POSTS (Many-to-Many relationship)
// ============================================================================

export const campaignPosts = mysqlTable("campaign_posts", {
  id: int("id").autoincrement().primaryKey(),
  campaignId: int("campaign_id").notNull(),
  postId: int("post_id").notNull(),
  
  addedAt: timestamp("added_at").defaultNow().notNull(),
});

// ============================================================================
// COMMENTS (Scraped from Instagram)
// ============================================================================

export const comments = mysqlTable("comments", {
  id: int("id").autoincrement().primaryKey(),
  postId: int("post_id").notNull(),
  
  // Instagram data
  instagramCommentId: varchar("instagram_comment_id", { length: 255 }).notNull().unique(),
  username: varchar("username", { length: 255 }).notNull(),
  text: text("text").notNull(),
  timestamp: timestamp("timestamp").notNull(),
  
  // Parent comment (for replies)
  parentCommentId: int("parent_comment_id"),
  
  // Sentiment analysis
  sentiment: mysqlEnum("sentiment", ["positive", "neutral", "negative", "toxic"]),
  sentimentScore: float("sentiment_score"), // -1 to 1
  sentimentConfidence: float("sentiment_confidence"), // 0 to 1
  
  // Categorization
  category: mysqlEnum("category", [
    "question",       // User asking a question
    "praise",         // Positive feedback
    "complaint",      // Negative feedback
    "spam",           // Spam/promotional
    "request",        // Feature/product request
    "general"         // General comment
  ]),
  
  // AI analysis
  aiSummary: text("ai_summary"), // Claude's summary of the comment
  suggestedResponse: text("suggested_response"), // AI-suggested reply
  
  // Response tracking
  hasResponded: boolean("has_responded").default(false),
  respondedAt: timestamp("responded_at"),
  responseText: text("response_text"),
  
  // Flags
  requiresAttention: boolean("requires_attention").default(false), // Needs human review
  isHidden: boolean("is_hidden").default(false), // Hidden by moderator
  
  createdAt: timestamp("created_at").defaultNow().notNull(),
  analyzedAt: timestamp("analyzed_at"),
});

export type Comment = typeof comments.$inferSelect;
export type InsertComment = typeof comments.$inferInsert;

// ============================================================================
// VISUAL ANALYSIS (Claude Vision analysis of images)
// ============================================================================

export const visualAnalysis = mysqlTable("visual_analysis", {
  id: int("id").autoincrement().primaryKey(),
  postId: int("post_id").notNull().unique(),
  
  // AI-generated analysis
  description: text("description").notNull(), // What's in the image
  composition: text("composition"), // Layout, rule of thirds, etc.
  colorPalette: json("color_palette").$type<string[]>(), // Dominant colors
  emotions: json("emotions").$type<string[]>(), // Emotions conveyed
  subjects: json("subjects").$type<string[]>(), // Main subjects
  style: varchar("style", { length: 100 }), // photographic, illustration, minimalist
  
  // Quality scores (0-10)
  visualQualityScore: float("visual_quality_score"),
  emotionalImpactScore: float("emotional_impact_score"),
  clarityScore: float("clarity_score"),
  brandAlignmentScore: float("brand_alignment_score"),
  
  // Performance correlation
  predictedEngagement: float("predicted_engagement"), // AI prediction
  actualEngagement: float("actual_engagement"), // Real performance
  
  // Insights
  strengths: json("strengths").$type<string[]>(), // What works well
  improvements: json("improvements").$type<string[]>(), // Suggestions
  
  // Similar posts
  similarPostIds: json("similar_post_ids").$type<number[]>(), // Similar high-performing posts
  
  analyzedAt: timestamp("analyzed_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().onUpdateNow().notNull(),
});

export type VisualAnalysis = typeof visualAnalysis.$inferSelect;
export type InsertVisualAnalysis = typeof visualAnalysis.$inferInsert;

// ============================================================================
// PERFORMANCE INSIGHTS (AI-generated insights)
// ============================================================================

export const performanceInsights = mysqlTable("performance_insights", {
  id: int("id").autoincrement().primaryKey(),
  postId: int("post_id"),
  campaignId: int("campaign_id"),
  accountId: int("account_id").notNull(),
  
  // Insight type
  insightType: mysqlEnum("insight_type", [
    "underperforming",   // Post not meeting expectations
    "overperforming",    // Post exceeding expectations
    "trending",          // Post going viral
    "negative_sentiment",// High negative comments
    "engagement_drop",   // Sudden drop in engagement
    "best_time",         // Optimal posting time found
    "content_suggestion",// Content recommendation
    "hashtag_recommendation", // Better hashtags
    "audience_insight"   // Audience behavior pattern
  ]).notNull(),
  
  // Insight details
  title: varchar("title", { length: 255 }).notNull(),
  description: text("description").notNull(),
  
  // Severity/Priority
  priority: mysqlEnum("priority", ["low", "medium", "high", "critical"]).default("medium").notNull(),
  
  // Recommendations
  recommendations: json("recommendations").$type<{
    action: string;
    reasoning: string;
    expectedImpact: string;
  }[]>(),
  
  // Metrics
  relatedMetrics: json("related_metrics").$type<Record<string, number>>(),
  
  // Status
  status: mysqlEnum("status", ["new", "viewed", "acted_on", "dismissed"]).default("new").notNull(),
  actedAt: timestamp("acted_at"),
  
  // AI confidence
  confidenceScore: float("confidence_score"), // 0-1
  
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type PerformanceInsight = typeof performanceInsights.$inferSelect;
export type InsertPerformanceInsight = typeof performanceInsights.$inferInsert;

// ============================================================================
// TRENDS (Content trends detected by agent)
// ============================================================================

export const trends = mysqlTable("trends", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("user_id").notNull(),
  accountId: int("account_id").notNull(),
  
  // Trend details
  trendType: mysqlEnum("trend_type", [
    "topic",          // Topic/subject matter
    "visual_style",   // Visual style/aesthetic
    "hashtag",        // Hashtag performance
    "posting_time",   // Best posting times
    "caption_style",  // Caption writing style
    "content_format"  // Type of content (carousel, single, video)
  ]).notNull(),
  
  name: varchar("name", { length: 255 }).notNull(),
  description: text("description"),
  
  // Performance metrics
  avgEngagementRate: float("avg_engagement_rate"),
  avgReach: float("avg_reach"),
  postCount: int("post_count").default(0),
  
  // Trend trajectory
  isRising: boolean("is_rising").default(true),
  trendScore: float("trend_score"), // 0-100
  
  // Time period
  detectedAt: timestamp("detected_at").defaultNow().notNull(),
  periodStart: timestamp("period_start").notNull(),
  periodEnd: timestamp("period_end").notNull(),
  
  // Related data
  relatedPostIds: json("related_post_ids").$type<number[]>(),
  relatedHashtags: json("related_hashtags").$type<string[]>(),
  
  updatedAt: timestamp("updated_at").defaultNow().onUpdateNow().notNull(),
});

export type Trend = typeof trends.$inferSelect;
export type InsertTrend = typeof trends.$inferInsert;

// ============================================================================
// ALERTS (Real-time notifications)
// ============================================================================

export const alerts = mysqlTable("alerts", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("user_id").notNull(),
  accountId: int("account_id"),
  postId: int("post_id"),
  campaignId: int("campaign_id"),
  
  // Alert type
  alertType: mysqlEnum("alert_type", [
    "viral_post",         // Post going viral
    "negative_comments",  // Spike in negative sentiment
    "goal_achieved",      // Campaign goal met
    "underperforming",    // Post not doing well
    "toxic_comment",      // Toxic comment detected
    "engagement_spike",   // Unusual engagement
    "follower_milestone", // Follower count milestone
    "best_performing",    // New best performing post
    "requires_response"   // Comment needs response
  ]).notNull(),
  
  title: varchar("title", { length: 255 }).notNull(),
  message: text("message").notNull(),
  
  // Severity
  severity: mysqlEnum("severity", ["info", "warning", "error", "success"]).default("info").notNull(),
  
  // Action items
  actionUrl: varchar("action_url", { length: 500 }), // Deep link to relevant page
  actionLabel: varchar("action_label", { length: 100 }), // "View Post", "Respond", etc.
  
  // Status
  isRead: boolean("is_read").default(false),
  readAt: timestamp("read_at"),
  
  // Notification channels
  notifiedViaEmail: boolean("notified_via_email").default(false),
  notifiedViaPush: boolean("notified_via_push").default(false),
  
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

export type Alert = typeof alerts.$inferSelect;
export type InsertAlert = typeof alerts.$inferInsert;

// ============================================================================
// AGENT RUNS (Tracking of agent execution)
// ============================================================================

export const agentRuns = mysqlTable("agent_runs", {
  id: int("id").autoincrement().primaryKey(),
  
  runType: mysqlEnum("run_type", [
    "comment_analysis",   // Analyze new comments
    "visual_analysis",    // Analyze images
    "performance_check",  // Check post performance
    "campaign_analysis",  // Analyze campaign
    "trend_detection",    // Detect trends
    "full_scan"          // Complete analysis
  ]).notNull(),
  
  // Scope
  accountId: int("account_id"),
  postId: int("post_id"),
  campaignId: int("campaign_id"),
  
  // Execution details
  status: mysqlEnum("status", ["running", "completed", "failed"]).default("running").notNull(),
  progress: float("progress").default(0), // 0-100
  
  // Results
  itemsProcessed: int("items_processed").default(0),
  insightsGenerated: int("insights_generated").default(0),
  alertsCreated: int("alerts_created").default(0),
  
  // Error tracking
  errorMessage: text("error_message"),
  
  // Performance
  startedAt: timestamp("started_at").defaultNow().notNull(),
  completedAt: timestamp("completed_at"),
  durationMs: int("duration_ms"),
  
  // Metadata
  metadata: json("metadata").$type<Record<string, any>>(),
});

export type AgentRun = typeof agentRuns.$inferSelect;
export type InsertAgentRun = typeof agentRuns.$inferInsert;

// ============================================================================
// AGENT SETTINGS (User preferences for agent behavior)
// ============================================================================

export const agentSettings = mysqlTable("agent_settings", {
  id: int("id").autoincrement().primaryKey(),
  userId: int("user_id").notNull().unique(),
  
  // Analysis frequency
  commentAnalysisEnabled: boolean("comment_analysis_enabled").default(true),
  commentAnalysisFrequency: int("comment_analysis_frequency").default(60), // minutes
  
  visualAnalysisEnabled: boolean("visual_analysis_enabled").default(true),
  performanceCheckEnabled: boolean("performance_check_enabled").default(true),
  performanceCheckFrequency: int("performance_check_frequency").default(240), // minutes
  
  trendDetectionEnabled: boolean("trend_detection_enabled").default(true),
  trendDetectionFrequency: int("trend_detection_frequency").default(1440), // daily
  
  // Alert preferences
  alertsEnabled: boolean("alerts_enabled").default(true),
  emailAlertsEnabled: boolean("email_alerts_enabled").default(true),
  pushAlertsEnabled: boolean("push_alerts_enabled").default(false),
  
  alertTypes: json("alert_types").$type<string[]>(), // Which alert types to receive
  minimumAlertSeverity: mysqlEnum("minimum_alert_severity", ["info", "warning", "error"]).default("warning"),
  
  // Auto-response settings
  autoResponseEnabled: boolean("auto_response_enabled").default(false),
  autoResponseToQuestions: boolean("auto_response_to_questions").default(false),
  autoResponseToPraise: boolean("auto_response_to_praise").default(false),
  autoResponseToComplaints: boolean("auto_response_to_complaints").default(false),
  
  // Thresholds
  underperformingThreshold: float("underperforming_threshold").default(0.5), // 50% of avg
  negativeSentimentThreshold: float("negative_sentiment_threshold").default(0.3), // 30% negative
  toxicCommentThreshold: float("toxic_comment_threshold").default(0.7), // 70% toxic score
  
  // Campaign tracking
  trackCampaignsByDefault: boolean("track_campaigns_by_default").default(true),
  
  updatedAt: timestamp("updated_at").defaultNow().onUpdateNow().notNull(),
});

export type AgentSettings = typeof agentSettings.$inferSelect;
export type InsertAgentSettings = typeof agentSettings.$inferInsert;

// ============================================================================
// RELATIONS
// ============================================================================

export const campaignsRelations = relations(campaigns, ({ many }) => ({
  posts: many(campaignPosts),
  insights: many(performanceInsights),
  alerts: many(alerts),
}));

export const commentsRelations = relations(comments, ({ one }) => ({
  post: one(comments, {
    fields: [comments.postId],
    references: [comments.id],
  }),
  parentComment: one(comments, {
    fields: [comments.parentCommentId],
    references: [comments.id],
  }),
}));

export const visualAnalysisRelations = relations(visualAnalysis, ({ one }) => ({
  post: one(visualAnalysis, {
    fields: [visualAnalysis.postId],
    references: [visualAnalysis.id],
  }),
}));
/**
 * SENTIMENT ANALYSIS SERVICE
 * Analyzes Instagram comments for sentiment, toxicity, and categorization
 */

import Anthropic from "@anthropic-ai/sdk";
import { db } from "../db";
import { comments, alerts } from "../agent-schema";
import { eq } from "drizzle-orm";

interface SentimentResult {
  sentiment: "positive" | "neutral" | "negative" | "toxic";
  score: number; // -1 to 1
  confidence: number; // 0 to 1
  category: "question" | "praise" | "complaint" | "spam" | "request" | "general";
  summary: string;
  suggestedResponse?: string;
  requiresAttention: boolean;
}

export class SentimentAnalysisService {
  private anthropic: Anthropic;

  constructor(apiKey: string) {
    this.anthropic = new Anthropic({ apiKey });
  }

  /**
   * Analyze a single comment
   */
  async analyzeComment(
    commentText: string,
    username: string,
    postContext?: {
      caption: string;
      topic: string;
    }
  ): Promise<SentimentResult> {
    try {
      const prompt = this.buildSentimentPrompt(commentText, username, postContext);

      const response = await this.anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 800,
        messages: [{
          role: "user",
          content: prompt
        }]
      });

      const content = response.content[0];
      if (content.type !== "text") {
        throw new Error("Unexpected response type");
      }

      // Parse structured JSON response
      const result = this.parseSentimentResponse(content.text);
      return result;

    } catch (error) {
      console.error("Sentiment analysis failed:", error);
      // Return safe defaults
      return {
        sentiment: "neutral",
        score: 0,
        confidence: 0,
        category: "general",
        summary: "Analysis failed",
        requiresAttention: false,
      };
    }
  }

  /**
   * Analyze multiple comments in batch
   */
  async analyzeBatch(
    comments: Array<{
      id: number;
      text: string;
      username: string;
    }>,
    postContext?: {
      caption: string;
      topic: string;
    }
  ): Promise<Map<number, SentimentResult>> {
    const results = new Map<number, SentimentResult>();

    // Process in smaller batches to avoid rate limits
    const batchSize = 5;
    for (let i = 0; i < comments.length; i += batchSize) {
      const batch = comments.slice(i, i + batchSize);
      
      await Promise.all(
        batch.map(async (comment) => {
          const result = await this.analyzeComment(
            comment.text,
            comment.username,
            postContext
          );
          results.set(comment.id, result);
        })
      );

      // Small delay between batches
      if (i + batchSize < comments.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    return results;
  }

  /**
   * Build sentiment analysis prompt
   */
  private buildSentimentPrompt(
    commentText: string,
    username: string,
    postContext?: {
      caption: string;
      topic: string;
    }
  ): string {
    return `Analyze this Instagram comment for sentiment and categorization.

COMMENT:
"${commentText}"

USERNAME: @${username}

${postContext ? `POST CONTEXT:
Topic: ${postContext.topic}
Caption: ${postContext.caption}
` : ''}

Analyze the comment and respond with a JSON object containing:

1. **sentiment**: One of:
   - "positive" - Supportive, enthusiastic, praising
   - "neutral" - Factual, informational, no strong emotion
   - "negative" - Critical, disappointed, frustrated
   - "toxic" - Hateful, abusive, threatening, harmful

2. **score**: Sentiment score from -1 (very negative) to 1 (very positive)

3. **confidence**: How confident you are in this analysis (0-1)

4. **category**: Primary category:
   - "question" - Asking a question
   - "praise" - Positive feedback or compliment
   - "complaint" - Negative feedback or complaint
   - "spam" - Promotional or spam content
   - "request" - Asking for something specific
   - "general" - General comment or reaction

5. **summary**: Brief 1-sentence summary of the comment's intent

6. **suggestedResponse**: If appropriate, suggest a helpful reply (2-3 sentences). Make it friendly, professional, and on-brand. Leave empty if no response needed.

7. **requiresAttention**: Boolean - true if this comment needs human review (complaints, toxic content, important questions)

CRITICAL: Respond ONLY with valid JSON. Do not include markdown formatting, code blocks, or any text outside the JSON structure.

Example format:
{
  "sentiment": "positive",
  "score": 0.8,
  "confidence": 0.95,
  "category": "praise",
  "summary": "User loves the sustainable approach to aviation fuel",
  "suggestedResponse": "Thank you so much! We're passionate about making aviation sustainable. Stay tuned for more updates!",
  "requiresAttention": false
}`;
  }

  /**
   * Parse Claude's JSON response
   */
  private parseSentimentResponse(text: string): SentimentResult {
    try {
      // Remove markdown code blocks if present
      let cleaned = text.trim();
      cleaned = cleaned.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();

      const parsed = JSON.parse(cleaned);

      return {
        sentiment: parsed.sentiment || "neutral",
        score: parsed.score || 0,
        confidence: parsed.confidence || 0,
        category: parsed.category || "general",
        summary: parsed.summary || "",
        suggestedResponse: parsed.suggestedResponse,
        requiresAttention: parsed.requiresAttention || false,
      };
    } catch (error) {
      console.error("Failed to parse sentiment response:", error);
      throw error;
    }
  }

  /**
   * Save analysis to database
   */
  async saveCommentAnalysis(
    commentId: number,
    analysis: SentimentResult
  ): Promise<void> {
    await db
      .update(comments)
      .set({
        sentiment: analysis.sentiment,
        sentimentScore: analysis.score,
        sentimentConfidence: analysis.confidence,
        category: analysis.category,
        aiSummary: analysis.summary,
        suggestedResponse: analysis.suggestedResponse,
        requiresAttention: analysis.requiresAttention,
        analyzedAt: new Date(),
      })
      .where(eq(comments.id, commentId));
  }

  /**
   * Detect sentiment trends for a post
   */
  async detectSentimentTrends(postId: number): Promise<{
    positivePercentage: number;
    negativePercentage: number;
    toxicPercentage: number;
    totalComments: number;
    requiresAttention: boolean;
    alertReason?: string;
  }> {
    const postComments = await db.query.comments.findMany({
      where: eq(comments.postId, postId),
    });

    const total = postComments.length;
    if (total === 0) {
      return {
        positivePercentage: 0,
        negativePercentage: 0,
        toxicPercentage: 0,
        totalComments: 0,
        requiresAttention: false,
      };
    }

    const positive = postComments.filter(c => c.sentiment === "positive").length;
    const negative = postComments.filter(c => c.sentiment === "negative").length;
    const toxic = postComments.filter(c => c.sentiment === "toxic").length;

    const positivePercentage = (positive / total) * 100;
    const negativePercentage = (negative / total) * 100;
    const toxicPercentage = (toxic / total) * 100;

    // Check if requires attention
    const requiresAttention = negativePercentage > 30 || toxicPercentage > 5;
    const alertReason = toxicPercentage > 5
      ? `High toxic comment rate (${toxicPercentage.toFixed(1)}%)`
      : negativePercentage > 30
      ? `High negative sentiment (${negativePercentage.toFixed(1)}%)`
      : undefined;

    return {
      positivePercentage,
      negativePercentage,
      toxicPercentage,
      totalComments: total,
      requiresAttention,
      alertReason,
    };
  }

  /**
   * Get sentiment statistics for a time period
   */
  async getSentimentStats(
    accountId: number,
    startDate: Date,
    endDate: Date
  ): Promise<{
    avgSentimentScore: number;
    totalComments: number;
    sentimentDistribution: Record<string, number>;
    categoryDistribution: Record<string, number>;
    topQuestions: Array<{ text: string; summary: string }>;
    topComplaints: Array<{ text: string; summary: string }>;
  }> {
    // This would query comments with joins to posts to filter by account and date
    // Implementation depends on your query structure
    
    // Placeholder return
    return {
      avgSentimentScore: 0,
      totalComments: 0,
      sentimentDistribution: {},
      categoryDistribution: {},
      topQuestions: [],
      topComplaints: [],
    };
  }

  /**
   * Generate response suggestions for multiple comments
   */
  async generateResponseSuggestions(
    comments: Array<{
      id: number;
      text: string;
      category: string;
    }>,
    brandVoice?: string
  ): Promise<Map<number, string>> {
    const suggestions = new Map<number, string>();

    for (const comment of comments) {
      // Only generate responses for certain categories
      if (!["question", "praise", "complaint"].includes(comment.category)) {
        continue;
      }

      try {
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 300,
          messages: [{
            role: "user",
            content: `Generate a friendly, professional response to this Instagram comment.

COMMENT: "${comment.text}"
CATEGORY: ${comment.category}
${brandVoice ? `BRAND VOICE: ${brandVoice}` : ''}

Write a 2-3 sentence response that:
- Addresses their ${comment.category}
- Is warm and authentic
- Maintains professional brand voice
- Encourages further engagement

Respond with ONLY the suggested reply text, no additional commentary.`
          }]
        });

        const content = response.content[0];
        if (content.type === "text") {
          suggestions.set(comment.id, content.text.trim());
        }

        // Rate limiting delay
        await new Promise(resolve => setTimeout(resolve, 500));

      } catch (error) {
        console.error(`Failed to generate response for comment ${comment.id}:`, error);
      }
    }

    return suggestions;
  }
}

export default SentimentAnalysisService;
/**
 * VISUAL ANALYSIS SERVICE
 * Uses Claude's vision to analyze images and predict/explain performance
 */

import Anthropic from "@anthropic-ai/sdk";
import { db } from "../db";
import { visualAnalysis, posts } from "../agent-schema";
import { eq } from "drizzle-orm";

interface VisualAnalysisResult {
  description: string;
  composition: string;
  colorPalette: string[];
  emotions: string[];
  subjects: string[];
  style: string;
  visualQualityScore: number;
  emotionalImpactScore: number;
  clarityScore: number;
  brandAlignmentScore: number;
  strengths: string[];
  improvements: string[];
  predictedEngagement: number;
}

export class VisualAnalysisService {
  private anthropic: Anthropic;

  constructor(apiKey: string) {
    this.anthropic = new Anthropic({ apiKey });
  }

  /**
   * Analyze an image using Claude's vision
   */
  async analyzeImage(
    imageUrl: string,
    postContext?: {
      caption: string;
      topic: string;
      hashtags: string[];
    },
    brandContext?: {
      primaryColor?: string;
      style?: string;
      values?: string[];
    }
  ): Promise<VisualAnalysisResult> {
    try {
      // Fetch image and convert to base64
      const imageResponse = await fetch(imageUrl);
      const imageBuffer = await imageResponse.arrayBuffer();
      const base64Image = Buffer.from(imageBuffer).toString('base64');
      
      // Determine media type from URL
      const mediaType = this.getMediaType(imageUrl);

      const prompt = this.buildVisualAnalysisPrompt(postContext, brandContext);

      const response = await this.anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 1500,
        messages: [{
          role: "user",
          content: [
            {
              type: "image",
              source: {
                type: "base64",
                media_type: mediaType,
                data: base64Image,
              },
            },
            {
              type: "text",
              text: prompt,
            },
          ],
        }],
      });

      const content = response.content[0];
      if (content.type !== "text") {
        throw new Error("Unexpected response type");
      }

      // Parse the structured response
      const result = this.parseVisualAnalysisResponse(content.text);
      return result;

    } catch (error) {
      console.error("Visual analysis failed:", error);
      throw error;
    }
  }

  /**
   * Build comprehensive visual analysis prompt
   */
  private buildVisualAnalysisPrompt(
    postContext?: {
      caption: string;
      topic: string;
      hashtags: string[];
    },
    brandContext?: {
      primaryColor?: string;
      style?: string;
      values?: string[];
    }
  ): string {
    return `Analyze this image in detail for Instagram performance optimization.

${postContext ? `POST CONTEXT:
Topic: ${postContext.topic}
Caption: ${postContext.caption}
Hashtags: ${postContext.hashtags.join(" ")}
` : ''}

${brandContext ? `BRAND CONTEXT:
Primary Color: ${brandContext.primaryColor || 'Not specified'}
Style: ${brandContext.style || 'Not specified'}
Values: ${brandContext.values?.join(", ") || 'Not specified'}
` : ''}

Provide a comprehensive analysis as a JSON object with these fields:

1. **description**: Detailed description of what's in the image (2-3 sentences)

2. **composition**: Analysis of visual composition:
   - Layout and structure
   - Use of rule of thirds
   - Balance and symmetry
   - Focal points

3. **colorPalette**: Array of 3-5 dominant colors (hex codes)

4. **emotions**: Array of emotions this image evokes (e.g., "inspiring", "calm", "energetic", "professional")

5. **subjects**: Array of main subjects/elements (e.g., "person", "product", "landscape", "technology")

6. **style**: Overall style (e.g., "photographic", "minimalist", "vibrant", "corporate", "lifestyle")

7. **visualQualityScore**: Technical quality score 0-10:
   - Lighting
   - Focus/sharpness
   - Resolution
   - Professional appearance

8. **emotionalImpactScore**: Emotional impact score 0-10:
   - How engaging/compelling
   - Emotional resonance
   - Storytelling quality

9. **clarityScore**: Clarity/understandability score 0-10:
   - Message clarity
   - Visual simplicity
   - Easy to understand at a glance

10. **brandAlignmentScore**: Brand alignment score 0-10:
    - How well it matches brand colors/style
    - Professional consistency
    - Brand values representation

11. **strengths**: Array of 3-5 key strengths (what works well)

12. **improvements**: Array of 3-5 suggested improvements (what could be better)

13. **predictedEngagement**: Predicted engagement level 0-100 based on:
    - Visual appeal
    - Trend alignment
    - Emotional impact
    - Instagram best practices

CRITICAL: Respond ONLY with valid JSON. No markdown, no code blocks, no additional text.

Example format:
{
  "description": "Professional photograph of sustainable aviation fuel production facility with modern equipment",
  "composition": "Well-balanced composition with strong leading lines directing to the main subject. Good use of depth of field.",
  "colorPalette": ["#2C5F2D", "#97BC62", "#E8F4EA", "#1A472A"],
  "emotions": ["professional", "innovative", "hopeful", "clean"],
  "subjects": ["industrial equipment", "clean technology", "sustainability"],
  "style": "corporate photography",
  "visualQualityScore": 8.5,
  "emotionalImpactScore": 7.0,
  "clarityScore": 9.0,
  "brandAlignmentScore": 8.5,
  "strengths": [
    "Professional lighting creates a premium feel",
    "Clean, modern aesthetic aligns with sustainability message",
    "Clear focal point draws attention effectively"
  ],
  "improvements": [
    "Could include human element for relatability",
    "Slightly more vibrant colors could increase engagement",
    "Consider adding text overlay for key message"
  ],
  "predictedEngagement": 72
}`;
  }

  /**
   * Parse visual analysis response
   */
  private parseVisualAnalysisResponse(text: string): VisualAnalysisResult {
    try {
      // Clean up markdown if present
      let cleaned = text.trim();
      cleaned = cleaned.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();

      const parsed = JSON.parse(cleaned);

      return {
        description: parsed.description || "",
        composition: parsed.composition || "",
        colorPalette: parsed.colorPalette || [],
        emotions: parsed.emotions || [],
        subjects: parsed.subjects || [],
        style: parsed.style || "",
        visualQualityScore: parsed.visualQualityScore || 0,
        emotionalImpactScore: parsed.emotionalImpactScore || 0,
        clarityScore: parsed.clarityScore || 0,
        brandAlignmentScore: parsed.brandAlignmentScore || 0,
        strengths: parsed.strengths || [],
        improvements: parsed.improvements || [],
        predictedEngagement: parsed.predictedEngagement || 0,
      };
    } catch (error) {
      console.error("Failed to parse visual analysis response:", error);
      throw error;
    }
  }

  /**
   * Save visual analysis to database
   */
  async saveVisualAnalysis(
    postId: number,
    analysis: VisualAnalysisResult
  ): Promise<void> {
    await db
      .insert(visualAnalysis)
      .values({
        postId,
        description: analysis.description,
        composition: analysis.composition,
        colorPalette: analysis.colorPalette,
        emotions: analysis.emotions,
        subjects: analysis.subjects,
        style: analysis.style,
        visualQualityScore: analysis.visualQualityScore,
        emotionalImpactScore: analysis.emotionalImpactScore,
        clarityScore: analysis.clarityScore,
        brandAlignmentScore: analysis.brandAlignmentScore,
        strengths: analysis.strengths,
        improvements: analysis.improvements,
        predictedEngagement: analysis.predictedEngagement,
      })
      .onDuplicateKeyUpdate({
        set: {
          description: analysis.description,
          composition: analysis.composition,
          colorPalette: analysis.colorPalette,
          emotions: analysis.emotions,
          subjects: analysis.subjects,
          style: analysis.style,
          visualQualityScore: analysis.visualQualityScore,
          emotionalImpactScore: analysis.emotionalImpactScore,
          clarityScore: analysis.clarityScore,
          brandAlignmentScore: analysis.brandAlignmentScore,
          strengths: analysis.strengths,
          improvements: analysis.improvements,
          predictedEngagement: analysis.predictedEngagement,
          updatedAt: new Date(),
        },
      });
  }

  /**
   * Compare images to find patterns
   */
  async compareImages(
    imageAnalyses: Array<{
      postId: number;
      analysis: VisualAnalysisResult;
      actualEngagement: number;
    }>
  ): Promise<{
    patterns: string[];
    recommendations: string[];
    topPerformers: number[];
  }> {
    // Build comparison prompt
    const comparisonData = imageAnalyses.map((item, idx) => ({
      index: idx,
      postId: item.postId,
      style: item.analysis.style,
      colorPalette: item.analysis.colorPalette,
      emotions: item.analysis.emotions,
      subjects: item.analysis.subjects,
      scores: {
        quality: item.analysis.visualQualityScore,
        emotional: item.analysis.emotionalImpactScore,
        clarity: item.analysis.clarityScore,
        brand: item.analysis.brandAlignmentScore,
      },
      actualEngagement: item.actualEngagement,
      predicted: item.analysis.predictedEngagement,
    }));

    try {
      const response = await this.anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 1000,
        messages: [{
          role: "user",
          content: `Analyze these image performance data points and identify patterns:

${JSON.stringify(comparisonData, null, 2)}

Identify:
1. **patterns**: What visual elements correlate with high engagement? (3-5 patterns)
2. **recommendations**: Actionable recommendations for future content (3-5 items)
3. **topPerformers**: Array of post IDs (indices) that performed best

Respond with ONLY valid JSON:
{
  "patterns": ["Pattern 1", "Pattern 2"],
  "recommendations": ["Recommendation 1", "Recommendation 2"],
  "topPerformers": [0, 3, 5]
}`
        }]
      });

      const content = response.content[0];
      if (content.type === "text") {
        let cleaned = content.text.trim();
        cleaned = cleaned.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
        
        const parsed = JSON.parse(cleaned);
        return {
          patterns: parsed.patterns || [],
          recommendations: parsed.recommendations || [],
          topPerformers: parsed.topPerformers || [],
        };
      }

      return { patterns: [], recommendations: [], topPerformers: [] };

    } catch (error) {
      console.error("Image comparison failed:", error);
      return { patterns: [], recommendations: [], topPerformers: [] };
    }
  }

  /**
   * Suggest image improvements
   */
  async suggestImprovements(
    currentAnalysis: VisualAnalysisResult,
    topPerformingAnalyses: VisualAnalysisResult[]
  ): Promise<string[]> {
    try {
      const response = await this.anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 600,
        messages: [{
          role: "user",
          content: `Current image analysis:
${JSON.stringify(currentAnalysis, null, 2)}

Top performing images have these characteristics:
${JSON.stringify(topPerformingAnalyses.map(a => ({
  style: a.style,
  colorPalette: a.colorPalette,
  emotions: a.emotions,
  scores: {
    quality: a.visualQualityScore,
    emotional: a.emotionalImpactScore,
  }
})), null, 2)}

Provide 5 specific, actionable improvements to make this image perform better.

Respond with ONLY a JSON array of strings:
["Improvement 1", "Improvement 2", "Improvement 3", "Improvement 4", "Improvement 5"]`
        }]
      });

      const content = response.content[0];
      if (content.type === "text") {
        let cleaned = content.text.trim();
        cleaned = cleaned.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
        return JSON.parse(cleaned);
      }

      return [];
    } catch (error) {
      console.error("Failed to suggest improvements:", error);
      return [];
    }
  }

  /**
   * Detect image type from URL
   */
  private getMediaType(url: string): "image/jpeg" | "image/png" | "image/gif" | "image/webp" {
    const ext = url.split('.').pop()?.toLowerCase();
    switch (ext) {
      case 'jpg':
      case 'jpeg':
        return 'image/jpeg';
      case 'png':
        return 'image/png';
      case 'gif':
        return 'image/gif';
      case 'webp':
        return 'image/webp';
      default:
        return 'image/jpeg';
    }
  }

  /**
   * Batch analyze multiple images
   */
  async analyzeBatch(
    images: Array<{
      postId: number;
      imageUrl: string;
      caption?: string;
      topic?: string;
    }>,
    brandContext?: {
      primaryColor?: string;
      style?: string;
      values?: string[];
    }
  ): Promise<Map<number, VisualAnalysisResult>> {
    const results = new Map<number, VisualAnalysisResult>();

    for (const image of images) {
      try {
        const analysis = await this.analyzeImage(
          image.imageUrl,
          image.caption && image.topic
            ? {
                caption: image.caption,
                topic: image.topic,
                hashtags: [],
              }
            : undefined,
          brandContext
        );

        results.set(image.postId, analysis);

        // Rate limiting
        await new Promise(resolve => setTimeout(resolve, 2000));

      } catch (error) {
        console.error(`Failed to analyze image for post ${image.postId}:`, error);
      }
    }

    return results;
  }
}

export default VisualAnalysisService;
/**
 * INSTAGRAM INTELLIGENCE AGENT
 * Main orchestrator for all AI-powered analysis and monitoring
 */

import { db } from "../db";
import { 
  posts, 
  comments, 
  visualAnalysis,
  performanceInsights,
  alerts,
  agentRuns,
  agentSettings,
  campaigns,
  postAnalytics 
} from "../agent-schema";
import { eq, and, desc, gte, lte, isNull } from "drizzle-orm";
import SentimentAnalysisService from "./sentiment-analysis.service";
import VisualAnalysisService from "./visual-analysis.service";
import InstagramGraphAPIService from "./instagram-api.service";

interface AgentConfig {
  anthropicApiKey: string;
  accountId?: number;
  userId?: number;
}

export class IntelligenceAgent {
  private sentimentService: SentimentAnalysisService;
  private visualService: VisualAnalysisService;
  private instagramService: InstagramGraphAPIService;
  private config: AgentConfig;

  constructor(config: AgentConfig) {
    this.config = config;
    this.sentimentService = new SentimentAnalysisService(config.anthropicApiKey);
    this.visualService = new VisualAnalysisService(config.anthropicApiKey);
    this.instagramService = new InstagramGraphAPIService();
  }

  /**
   * Run complete analysis for a post
   */
  async analyzePost(postId: number): Promise<void> {
    const runId = await this.startRun("full_scan", postId);

    try {
      // Get post data
      const post = await db.query.posts.findFirst({
        where: eq(posts.id, postId),
        with: {
          account: true,
          analytics: true,
        },
      });

      if (!post) {
        throw new Error(`Post ${postId} not found`);
      }

      // 1. Analyze image if not done yet
      await this.analyzePostImage(post);

      // 2. Fetch and analyze comments
      await this.analyzePostComments(post);

      // 3. Check performance
      await this.checkPostPerformance(post);

      // 4. Generate insights
      await this.generatePostInsights(post);

      await this.completeRun(runId, { itemsProcessed: 1 });

    } catch (error) {
      console.error(`Post analysis failed for ${postId}:`, error);
      await this.failRun(runId, error.message);
      throw error;
    }
  }

  /**
   * Analyze image for a post
   */
  private async analyzePostImage(post: any): Promise<void> {
    // Check if already analyzed
    const existing = await db.query.visualAnalysis.findFirst({
      where: eq(visualAnalysis.postId, post.id),
    });

    if (existing) {
      console.log(`Post ${post.id} already has visual analysis`);
      return;
    }

    console.log(`Analyzing image for post ${post.id}...`);

    try {
      const analysis = await this.visualService.analyzeImage(
        post.imageUrl,
        {
          caption: post.caption,
          topic: post.topic || "",
          hashtags: post.hashtags || [],
        }
      );

      await this.visualService.saveVisualAnalysis(post.id, analysis);

      console.log(`âœ… Visual analysis complete for post ${post.id}`);

    } catch (error) {
      console.error(`Visual analysis failed for post ${post.id}:`, error);
    }
  }

  /**
   * Fetch and analyze comments for a post
   */
  private async analyzePostComments(post: any): Promise<void> {
    if (!post.instagramMediaId || !post.account.accessToken) {
      console.log(`Post ${post.id} not published yet, skipping comment analysis`);
      return;
    }

    try {
      // Fetch comments from Instagram
      const response = await fetch(
        `https://graph.facebook.com/v21.0/${post.instagramMediaId}/comments?fields=id,username,text,timestamp&access_token=${post.account.accessToken}`
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch comments: ${response.statusText}`);
      }

      const data = await response.json();
      const instagramComments = data.data || [];

      console.log(`Found ${instagramComments.length} comments for post ${post.id}`);

      // Save comments to database and analyze
      for (const igComment of instagramComments) {
        // Check if comment already exists
        const existing = await db.query.comments.findFirst({
          where: eq(comments.instagramCommentId, igComment.id),
        });

        if (existing) {
          continue; // Already processed
        }

        // Save comment
        const [savedComment] = await db
          .insert(comments)
          .values({
            postId: post.id,
            instagramCommentId: igComment.id,
            username: igComment.username,
            text: igComment.text,
            timestamp: new Date(igComment.timestamp),
          })
          .$returningId();

        // Analyze sentiment
        const analysis = await this.sentimentService.analyzeComment(
          igComment.text,
          igComment.username,
          {
            caption: post.caption,
            topic: post.topic || "",
          }
        );

        await this.sentimentService.saveCommentAnalysis(savedComment.id, analysis);

        // Create alert if requires attention
        if (analysis.requiresAttention) {
          await this.createAlert({
            userId: post.userId,
            accountId: post.accountId,
            postId: post.id,
            alertType: analysis.sentiment === "toxic" ? "toxic_comment" : "requires_response",
            title: `Comment needs attention on post`,
            message: `${analysis.category}: "${igComment.text.substring(0, 100)}..."`,
            severity: analysis.sentiment === "toxic" ? "error" : "warning",
          });
        }
      }

      // Check for sentiment trends
      const trends = await this.sentimentService.detectSentimentTrends(post.id);

      if (trends.requiresAttention && trends.alertReason) {
        await this.createAlert({
          userId: post.userId,
          accountId: post.accountId,
          postId: post.id,
          alertType: "negative_comments",
          title: "High negative sentiment detected",
          message: trends.alertReason,
          severity: "warning",
        });
      }

    } catch (error) {
      console.error(`Comment analysis failed for post ${post.id}:`, error);
    }
  }

  /**
   * Check post performance and detect issues
   */
  private async checkPostPerformance(post: any): Promise<void> {
    if (!post.analytics) {
      console.log(`Post ${post.id} has no analytics yet`);
      return;
    }

    const analytics = post.analytics;

    // Get account average performance
    const accountPosts = await db.query.posts.findMany({
      where: and(
        eq(posts.accountId, post.accountId),
        eq(posts.status, "published")
      ),
      with: { analytics: true },
    });

    const publishedWithAnalytics = accountPosts.filter(p => p.analytics);

    if (publishedWithAnalytics.length < 3) {
      console.log("Not enough data for performance comparison");
      return;
    }

    // Calculate averages
    const avgLikes = publishedWithAnalytics.reduce((sum, p) => sum + (p.analytics?.likes || 0), 0) / publishedWithAnalytics.length;
    const avgComments = publishedWithAnalytics.reduce((sum, p) => sum + (p.analytics?.comments || 0), 0) / publishedWithAnalytics.length;
    const avgReach = publishedWithAnalytics.reduce((sum, p) => sum + (p.analytics?.reach || 0), 0) / publishedWithAnalytics.length;

    // Check for underperformance (< 50% of average)
    const isUnderperforming = 
      analytics.likes < avgLikes * 0.5 ||
      analytics.reach < avgReach * 0.5;

    if (isUnderperforming) {
      await this.createInsight({
        postId: post.id,
        accountId: post.accountId,
        insightType: "underperforming",
        title: "Post underperforming",
        description: `This post is getting ${((analytics.likes / avgLikes) * 100).toFixed(0)}% of average engagement`,
        priority: "high",
        recommendations: [
          {
            action: "Review visual content",
            reasoning: "Low engagement may indicate image doesn't resonate",
            expectedImpact: "Higher future performance",
          },
          {
            action: "Analyze posting time",
            reasoning: "May have posted during low-activity hours",
            expectedImpact: "Better timing strategy",
          },
        ],
        relatedMetrics: {
          likes: analytics.likes,
          avgLikes,
          reach: analytics.reach,
          avgReach,
        },
      });

      await this.createAlert({
        userId: post.userId,
        accountId: post.accountId,
        postId: post.id,
        alertType: "underperforming",
        title: "Post underperforming",
        message: `Getting ${((analytics.likes / avgLikes) * 100).toFixed(0)}% of average engagement`,
        severity: "warning",
      });
    }

    // Check for overperformance (> 150% of average)
    const isOverperforming = 
      analytics.likes > avgLikes * 1.5 ||
      analytics.reach > avgReach * 1.5;

    if (isOverperforming) {
      await this.createInsight({
        postId: post.id,
        accountId: post.accountId,
        insightType: "overperforming",
        title: "Post exceeding expectations!",
        description: `This post is getting ${((analytics.likes / avgLikes) * 100).toFixed(0)}% of average engagement`,
        priority: "high",
        recommendations: [
          {
            action: "Analyze success factors",
            reasoning: "Understand what made this post successful",
            expectedImpact: "Replicate success in future posts",
          },
          {
            action: "Create similar content",
            reasoning: "Audience clearly resonates with this style",
            expectedImpact: "Sustained high engagement",
          },
        ],
        relatedMetrics: {
          likes: analytics.likes,
          avgLikes,
          reach: analytics.reach,
          avgReach,
        },
      });

      await this.createAlert({
        userId: post.userId,
        accountId: post.accountId,
        postId: post.id,
        alertType: "overperforming",
        title: "ðŸŽ‰ Post going viral!",
        message: `${((analytics.likes / avgLikes) * 100).toFixed(0)}% above average engagement!`,
        severity: "success",
      });
    }
  }

  /**
   * Generate actionable insights for a post
   */
  private async generatePostInsights(post: any): Promise<void> {
    // Get visual analysis
    const visual = await db.query.visualAnalysis.findFirst({
      where: eq(visualAnalysis.postId, post.id),
    });

    // Get comment sentiment
    const postComments = await db.query.comments.findMany({
      where: eq(comments.postId, post.id),
    });

    // Generate insights based on data
    // (This would involve more sophisticated analysis)
    
    console.log(`Generated insights for post ${post.id}`);
  }

  /**
   * Analyze campaign performance
   */
  async analyzeCampaign(campaignId: number): Promise<void> {
    const runId = await this.startRun("campaign_analysis", undefined, campaignId);

    try {
      // Get campaign with posts
      const campaign = await db.query.campaigns.findFirst({
        where: eq(campaigns.id, campaignId),
      });

      if (!campaign) {
        throw new Error(`Campaign ${campaignId} not found`);
      }

      // Get campaign posts
      const campaignPostLinks = await db.query.campaignPosts.findMany({
        where: eq(campaignPosts.campaignId, campaignId),
      });

      const postIds = campaignPostLinks.map(cp => cp.postId);

      // Analyze each post
      for (const postId of postIds) {
        await this.analyzePost(postId);
      }

      // Generate campaign-level insights
      await this.generateCampaignInsights(campaign, postIds);

      await this.completeRun(runId, { itemsProcessed: postIds.length });

    } catch (error) {
      console.error(`Campaign analysis failed for ${campaignId}:`, error);
      await this.failRun(runId, error.message);
      throw error;
    }
  }

  /**
   * Generate campaign-level insights
   */
  private async generateCampaignInsights(campaign: any, postIds: number[]): Promise<void> {
    // Get all posts with analytics
    const campaignPosts = await db.query.posts.findMany({
      where: eq(posts.id, postIds[0]), // This would be an IN query
      with: { analytics: true },
    });

    // Calculate campaign metrics
    const totalLikes = campaignPosts.reduce((sum, p) => sum + (p.analytics?.likes || 0), 0);
    const totalReach = campaignPosts.reduce((sum, p) => sum + (p.analytics?.reach || 0), 0);
    const avgEngagement = totalLikes / campaignPosts.length;

    // Check if goal met
    if (campaign.targetMetric && campaign.targetValue) {
      const metricValue = campaign.targetMetric === "reach" ? totalReach : avgEngagement;
      const goalMet = metricValue >= campaign.targetValue;

      if (goalMet) {
        await this.createAlert({
          userId: campaign.userId,
          campaignId: campaign.id,
          alertType: "goal_achieved",
          title: `Campaign "${campaign.name}" goal achieved!`,
          message: `Reached ${metricValue.toFixed(0)} ${campaign.targetMetric}`,
          severity: "success",
        });
      }
    }
  }

  /**
   * Detect trends across posts
   */
  async detectTrends(accountId: number, days: number = 30): Promise<void> {
    // Get posts from last N days
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);

    // This would analyze posts and detect patterns
    // e.g., certain hashtags performing better, best posting times, etc.
    
    console.log(`Trend detection for account ${accountId}`);
  }

  /**
   * Helper: Start agent run
   */
  private async startRun(
    runType: string,
    postId?: number,
    campaignId?: number
  ): Promise<number> {
    const [run] = await db
      .insert(agentRuns)
      .values({
        runType: runType as any,
        postId,
        campaignId,
        accountId: this.config.accountId,
        status: "running",
      })
      .$returningId();

    return run.id;
  }

  /**
   * Helper: Complete agent run
   */
  private async completeRun(runId: number, results: {
    itemsProcessed?: number;
    insightsGenerated?: number;
    alertsCreated?: number;
  }): Promise<void> {
    const startTime = await db.query.agentRuns.findFirst({
      where: eq(agentRuns.id, runId),
    });

    const duration = startTime ? Date.now() - new Date(startTime.startedAt).getTime() : 0;

    await db
      .update(agentRuns)
      .set({
        status: "completed",
        completedAt: new Date(),
        durationMs: duration,
        ...results,
      })
      .where(eq(agentRuns.id, runId));
  }

  /**
   * Helper: Fail agent run
   */
  private async failRun(runId: number, errorMessage: string): Promise<void> {
    await db
      .update(agentRuns)
      .set({
        status: "failed",
        completedAt: new Date(),
        errorMessage,
      })
      .where(eq(agentRuns.id, runId));
  }

  /**
   * Helper: Create insight
   */
  private async createInsight(data: any): Promise<void> {
    await db.insert(performanceInsights).values(data);
  }

  /**
   * Helper: Create alert
   */
  private async createAlert(data: any): Promise<void> {
    await db.insert(alerts).values(data);
  }
}

export default IntelligenceAgent;
/**
 * MCP PLAYWRIGHT INTEGRATION
 * Web automation and visual analysis using Playwright
 * Can navigate Instagram, take screenshots, extract data
 */

import { chromium, Browser, Page } from 'playwright';
import Anthropic from '@anthropic-ai/sdk';

interface MCPPlaywrightConfig {
  headless?: boolean;
  timeout?: number;
  anthropicApiKey: string;
}

interface ScreenshotAnalysis {
  description: string;
  elements: Array<{
    type: string;
    content: string;
    position: string;
  }>;
  metrics: Record<string, number>;
  insights: string[];
}

export class MCPPlaywrightService {
  private browser: Browser | null = null;
  private config: MCPPlaywrightConfig;
  private anthropic: Anthropic;

  constructor(config: MCPPlaywrightConfig) {
    this.config = {
      headless: true,
      timeout: 30000,
      ...config,
    };
    this.anthropic = new Anthropic({ apiKey: config.anthropicApiKey });
  }

  /**
   * Initialize browser
   */
  async initialize(): Promise<void> {
    if (this.browser) {
      return; // Already initialized
    }

    this.browser = await chromium.launch({
      headless: this.config.headless,
    });
  }

  /**
   * Close browser
   */
  async close(): Promise<void> {
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
  }

  /**
   * Navigate to Instagram post and analyze
   */
  async analyzeInstagramPost(postUrl: string): Promise<{
    screenshot: Buffer;
    metrics: {
      likes: number;
      comments: number;
      engagement: number;
    };
    visual Analysis: ScreenshotAnalysis;
  }> {
    await this.initialize();

    const page = await this.browser!.newPage();

    try {
      // Navigate to post
      await page.goto(postUrl, { waitUntil: 'networkidle' });

      // Wait for content to load
      await page.waitForTimeout(3000);

      // Extract metrics from page
      const metrics = await this.extractMetrics(page);

      // Take screenshot
      const screenshot = await page.screenshot({
        fullPage: true,
        type: 'png',
      });

      // Analyze screenshot with Claude Vision
      const visualAnalysis = await this.analyzeScreenshot(screenshot);

      return {
        screenshot,
        metrics,
        visualAnalysis,
      };

    } finally {
      await page.close();
    }
  }

  /**
   * Extract metrics from Instagram page
   */
  private async extractMetrics(page: Page): Promise<{
    likes: number;
    comments: number;
    engagement: number;
  }> {
    try {
      // This is example code - actual selectors may vary
      const likesText = await page.textContent('[aria-label*="likes"]') || '0';
      const commentsText = await page.textContent('[aria-label*="comments"]') || '0';

      const likes = this.parseNumber(likesText);
      const comments = this.parseNumber(commentsText);

      return {
        likes,
        comments,
        engagement: likes + comments,
      };
    } catch (error) {
      console.error('Failed to extract metrics:', error);
      return { likes: 0, comments: 0, engagement: 0 };
    }
  }

  /**
   * Analyze screenshot with Claude Vision
   */
  private async analyzeScreenshot(screenshot: Buffer): Promise<ScreenshotAnalysis> {
    try {
      const base64Image = screenshot.toString('base64');

      const response = await this.anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1500,
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'image',
                source: {
                  type: 'base64',
                  media_type: 'image/png',
                  data: base64Image,
                },
              },
              {
                type: 'text',
                text: `Analyze this Instagram post screenshot in detail.

Provide a JSON response with:

1. **description**: What you see in the post (2-3 sentences)

2. **elements**: Array of key visual elements:
   - type: "image", "text", "profile", "metrics"
   - content: description of the element
   - position: "top", "center", "bottom", etc.

3. **metrics**: Extracted numbers:
   - likes: number of likes visible
   - comments: number of comments visible
   - followers: if visible

4. **insights**: Array of 3-5 observations about:
   - Visual design quality
   - Engagement levels
   - Content effectiveness
   - Professional appearance

CRITICAL: Respond ONLY with valid JSON, no markdown, no code blocks.

Example:
{
  "description": "Professional sustainability post with clean modern design",
  "elements": [
    {"type": "image", "content": "Main product photo with green background", "position": "center"},
    {"type": "text", "content": "Caption about renewable energy", "position": "bottom"}
  ],
  "metrics": {"likes": 1250, "comments": 45},
  "insights": [
    "High-quality professional photography",
    "Strong engagement relative to follower count",
    "Clear branding and messaging"
  ]
}`,
              },
            ],
          },
        ],
      });

      const content = response.content[0];
      if (content.type === 'text') {
        let cleaned = content.text.trim();
        cleaned = cleaned.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        return JSON.parse(cleaned);
      }

      throw new Error('Unexpected response format');
    } catch (error) {
      console.error('Screenshot analysis failed:', error);
      return {
        description: 'Analysis failed',
        elements: [],
        metrics: {},
        insights: [],
      };
    }
  }

  /**
   * Scrape Instagram profile data
   */
  async scrapeProfile(username: string): Promise<{
    followers: number;
    following: number;
    posts: number;
    bio: string;
    recentPosts: Array<{
      url: string;
      likes: number;
      comments: number;
    }>;
  }> {
    await this.initialize();

    const page = await this.browser!.newPage();

    try {
      await page.goto(`https://www.instagram.com/${username}/`, {
        waitUntil: 'networkidle',
      });

      await page.waitForTimeout(3000);

      // Extract profile data
      // (This would need actual implementation based on Instagram's structure)

      return {
        followers: 0,
        following: 0,
        posts: 0,
        bio: '',
        recentPosts: [],
      };

    } finally {
      await page.close();
    }
  }

  /**
   * Monitor Instagram post over time
   */
  async monitorPost(
    postUrl: string,
    intervalMinutes: number = 60,
    durationHours: number = 24
  ): Promise<Array<{
    timestamp: Date;
    likes: number;
    comments: number;
    screenshot: Buffer;
  }>> {
    const snapshots: Array<any> = [];
    const endTime = Date.now() + durationHours * 60 * 60 * 1000;

    while (Date.now() < endTime) {
      const analysis = await this.analyzeInstagramPost(postUrl);

      snapshots.push({
        timestamp: new Date(),
        likes: analysis.metrics.likes,
        comments: analysis.metrics.comments,
        screenshot: analysis.screenshot,
      });

      // Wait for next interval
      await new Promise(resolve => setTimeout(resolve, intervalMinutes * 60 * 1000));
    }

    return snapshots;
  }

  /**
   * Compare two posts visually
   */
  async comparePosts(url1: string, url2: string): Promise<{
    similarities: string[];
    differences: string[];
    recommendation: string;
  }> {
    const [analysis1, analysis2] = await Promise.all([
      this.analyzeInstagramPost(url1),
      this.analyzeInstagramPost(url2),
    ]);

    try {
      const response = await this.anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 1000,
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'image',
                source: {
                  type: 'base64',
                  media_type: 'image/png',
                  data: analysis1.screenshot.toString('base64'),
                },
              },
              {
                type: 'image',
                source: {
                  type: 'base64',
                  media_type: 'image/png',
                  data: analysis2.screenshot.toString('base64'),
                },
              },
              {
                type: 'text',
                text: `Compare these two Instagram posts.

Post 1 metrics: ${JSON.stringify(analysis1.metrics)}
Post 2 metrics: ${JSON.stringify(analysis2.metrics)}

Provide JSON with:
- **similarities**: Array of visual/content similarities
- **differences**: Array of key differences
- **recommendation**: Which approach works better and why

Respond ONLY with valid JSON.`,
              },
            ],
          },
        ],
      });

      const content = response.content[0];
      if (content.type === 'text') {
        let cleaned = content.text.trim();
        cleaned = cleaned.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
        return JSON.parse(cleaned);
      }

      throw new Error('Unexpected response');
    } catch (error) {
      console.error('Comparison failed:', error);
      return {
        similarities: [],
        differences: [],
        recommendation: 'Analysis failed',
      };
    }
  }

  /**
   * Analyze competitor posts
   */
  async analyzeCompetitor(username: string, postCount: number = 10): Promise<{
    profile: any;
    posts: Array<{
      url: string;
      analysis: ScreenshotAnalysis;
      metrics: any;
    }>;
    insights: string[];
  }> {
    await this.initialize();

    // Scrape profile
    const profile = await this.scrapeProfile(username);

    // Analyze recent posts
    const posts = [];
    for (const post of profile.recentPosts.slice(0, postCount)) {
      const analysis = await this.analyzeInstagramPost(post.url);
      posts.push({
        url: post.url,
        analysis: analysis.visualAnalysis,
        metrics: analysis.metrics,
      });

      // Rate limiting
      await new Promise(resolve => setTimeout(resolve, 5000));
    }

    // Generate competitive insights
    const insights = [
      'Analysis of competitor posting patterns',
      // More insights would be generated here
    ];

    return {
      profile,
      posts,
      insights,
    };
  }

  /**
   * Helper: Parse number from text
   */
  private parseNumber(text: string): number {
    // Remove commas, 'k' for thousands, 'm' for millions
    const cleaned = text.toLowerCase().replace(/[^0-9.km]/g, '');
    
    if (cleaned.includes('m')) {
      return parseFloat(cleaned) * 1000000;
    }
    if (cleaned.includes('k')) {
      return parseFloat(cleaned) * 1000;
    }
    return parseFloat(cleaned) || 0;
  }

  /**
   * Take screenshot of any URL
   */
  async screenshot(url: string, fullPage: boolean = true): Promise<Buffer> {
    await this.initialize();

    const page = await this.browser!.newPage();

    try {
      await page.goto(url, { waitUntil: 'networkidle' });
      return await page.screenshot({ fullPage, type: 'png' });
    } finally {
      await page.close();
    }
  }

  /**
   * Extract text from page
   */
  async extractText(url: string): Promise<string> {
    await this.initialize();

    const page = await this.browser!.newPage();

    try {
      await page.goto(url, { waitUntil: 'networkidle' });
      return await page.textContent('body') || '';
    } finally {
      await page.close();
    }
  }
}

export default MCPPlaywrightService;
